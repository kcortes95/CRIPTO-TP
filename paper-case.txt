// Parse parameters
// e.g.: -d -s Albert.bmp -m Paris.bmp -k 4 -n 8 --dir color280x440/

// Matrix A
//    A[0][0] = 3;
//    A[0][1] = 7;
//    A[1][0] = 6;
//    A[1][1] = 1;
//    A[2][0] = 2;
//    A[2][1] = 5;
//    A[3][0] = 6;
//    A[3][1] = 6;

// Matrix S
//    S[0][0] = 2L;
//    S[0][1] = 5L;
//    S[0][2] = 2L;
//    S[0][3] = 3L;
//
//    S[1][0] = 3L;
//    S[1][1] = 6L;
//    S[1][2] = 4L;
//    S[1][3] = 5L;
//
//    S[2][0] = 4L;
//    S[2][1] = 7L;
//    S[2][2] = 4L;
//    S[2][3] = 6L;
//
//    S[3][0] = 1L;
//    S[3][1] = 4L;
//    S[3][2] = 1L;
//    S[3][3] = 7L;


// Matrix V
//    long **VDemo = (long **) malloc(n * sizeof(long *));
//    for (int i = 0; i < n; i++) VDemo[i] = (long *) calloc(n, sizeof(long));

//    VDemo[0][0] = 62L;
//    VDemo[0][1] = 59L;
//    VDemo[0][2] = 43L;
//    VDemo[0][3] = 84L;
//
//    VDemo[1][0] = 40L;
//    VDemo[1][1] = 28L;
//    VDemo[1][2] = 28L;
//    VDemo[1][3] = 48L;
//
//    VDemo[2][0] = 83L;
//    VDemo[2][1] = 62L;
//    VDemo[2][2] = 58L;
//    VDemo[2][3] = 102L;
//
//    VDemo[3][0] = 23L;
//    VDemo[3][1] = 20L;
//    VDemo[3][2] = 16L;
//    VDemo[3][3] = 30L;


   //Start desencryption example from paper

    k = 2;
    n = 4;

    // Initialize recovered R
    long **recoveredR = (long **) malloc(n * sizeof(long *));
    for (int i = 0; i < n; i++)
        recoveredR[i] = (long *) calloc((size_t) n, sizeof(long));

    // Matrix with 1s at first column and cjs at second column
    long **matCj = matrixCj(k, k); //NEW
    printMatrix(k, k, matCj, "matCj:");

    // Initialize Gxy matrix (but it's really a vector)
    long **Gxy = (long **) malloc(k * sizeof(long *));
    for (int i = 0; i < k; i++)
        Gxy[i] = (long *) calloc(1, sizeof(long));

    // Initialize G vector of k matrices Gj
    long ***matG = (long ***) malloc(k * sizeof(long **)); //TODO: free
    for (int j = 0; j < k; j++) {
        long **G_i = (long **) malloc(n * sizeof(long *));
        for (int i = 0; i < n; i++)
            G_i[i] = (long *) calloc((size_t) (int) ceil((double) n / k), sizeof(long));
        matG[j] = G_i;
    }

    matG[0][0][0] = 36;
    matG[0][0][1] = 92;
    matG[0][1][0] = 101;
    matG[0][1][1] = 58;
    matG[0][2][0] = 126;
    matG[0][2][1] = 142;
    matG[0][3][0] = 26;
    matG[0][3][1] = 163;

    matG[1][0][0] = 71;
    matG[1][0][1] = 132;
    matG[1][1][0] = 169;
    matG[1][1][1] = 47;
    matG[1][2][0] = 198;
    matG[1][2][1] = 72;
    matG[1][3][0] = 14;
    matG[1][3][1] = 150;

    // Traverse all positions of G matrices
    for (int x = 0; x < n; x++) {
        for (int y = 0; y < (int) ceil((double) n / k); y++) {
            // Get current G for x and y
            Gxy = resultG(x, y, matG, k);

            printf("\n***");
            printf("\nGxy con x:%d | y:%d", x, y);
            printMatrix(1, k, Gxy, "");
            printf("***\n");

            // Calculate solution vector
            //long **concatCjGs = concatMatMat(matCj, Gxy, k, k, (int) ceil((double) n / k)); //ORIGINAL
            long **concatCjGs = concatMatMat(matCj, Gxy, k, k, 1);
            printMatrix(k + 1, k, concatCjGs, "la concatCjGs:");

            long *solutionVector = gaussJordan(k, concatCjGs, inverses);

            printVector(k, solutionVector, "solutionVector:");

            // Save solution vector at recovered R
            recoveredR[x][0 + k * y] = solutionVector[0];
            recoveredR[x][1 + k * y] = solutionVector[1];
//            recoveredR[x][2 + k * y] = solutionVector[2];
//            recoveredR[x][3 + k * y] = solutionVector[3];

            printMatrix(n, n, recoveredR, "Recovered R:");

            free(solutionVector);
        }
    }
